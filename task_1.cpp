#include <iostream> // Для введення/виведення (cin, cout)
 #include <string>   // Для роботи з рядками (string, getline, find, substr, stoi)
 #include <sstream>  // Для роботи з рядковими потоками (stringstream) - зручно для формування рядків
 #include <numeric>  // Для std::gcd (Найбільший спільний дільник) - опціонально, для спрощення дробів
 #include <cmath>    // Для std::abs (абсолютне значення)
 
 // Використання стандартного простору імен для скорочення (наприклад, cout замість std::cout)
 using namespace std;
 
 // Функція для обчислення Найбільшого Спільного Дільника (НСД)
 // Повертає завжди додатний НСД. Опціональна функція.
 int gcd(int a, int b) {
     // Використовуємо стандартну функцію std::gcd і беремо модуль результату
     return std::abs(std::gcd(a, b));
 }
 
 // Оголошення класу для представлення дробів
 class Fraction {
 // Приватна секція: члени класу доступні лише зсередини самого класу
 private:
     int numerator;   // Змінна для зберігання чисельника
     int denominator; // Змінна для зберігання знаменника
 
     // Приватний метод для спрощення дробу (опціонально)
     // Ділить чисельник і знаменник на їх НСД
     void simplify() {
         // Перевірка на нульовий знаменник (хоча за умовою його не має бути)
         if (denominator == 0) {
              cerr << "Помилка (simplify): Знаменник не може бути нулем." << endl;
              return; // Вихід, якщо знаменник 0
         }
         // Якщо чисельник 0, дріб дорівнює 0. Канонічна форма 0/1.
         if (numerator == 0) {
             denominator = 1; // Встановлюємо знаменник в 1
             return; // Вихід
         }
 
         // Обчислюємо НСД чисельника і знаменника
         int common_divisor = gcd(numerator, denominator);
         // Ділимо чисельник на НСД
         numerator /= common_divisor;
         // Ділимо знаменник на НСД
         denominator /= common_divisor;
 
         // Гарантуємо, що знак зберігається в чисельнику, а знаменник завжди додатний
         if (denominator < 0) {
             numerator = -numerator;     // Змінюємо знак чисельника
             denominator = -denominator; // Робимо знаменник додатним
         }
     }
 
 // Публічна секція: члени класу доступні ззовні
 public:
     // Конструктор класу: викликається при створенні об'єкта Fraction
     // Приймає чисельник (num) і знаменник (den)
     Fraction(int num, int den) {
         // Перевірка на нульовий знаменник при створенні об'єкта
         if (den == 0) {
             // Виводимо помилку, але за умовою задачі продовжуємо, встановивши знаменник 1
              cerr << "Помилка (конструктор): Знаменник не може бути нулем. Встановлено 1." << endl;
              den = 1; // Встановлюємо безпечне значення
         }
 
         // Ініціалізуємо члени класу переданими значеннями
         numerator = num;
         denominator = den;
 
         // Нормалізація знаку: мінус завжди має бути у чисельника
         if (denominator < 0) {
             numerator = -numerator;     // Переносимо знак в чисельник
             denominator = -denominator; // Робимо знаменник додатним
         }
 
          // Розкоментуйте наступний рядок, якщо хочете, щоб дроби автоматично спрощувалися при створенні
         // simplify();
     }
 
     // Метод для отримання рядкового представлення дробу
     string toString() {
         stringstream ss; // Створюємо рядковий потік для формування результату
 
         // Беремо абсолютні значення для зручності обчислення цілої та дробової частин
         int num_abs = abs(numerator);
         int den_abs = abs(denominator); // Знаменник вже має бути додатнім
 
         // Окрема обробка випадку, коли дріб дорівнює нулю
         if (numerator == 0) {
             return "0"; // Повертаємо рядок "0"
         }
 
         // Визначаємо, чи є дріб від'ємним
         bool is_negative = numerator < 0;
         // Обчислюємо цілу частину (результат цілочисельного ділення)
         int whole_part = num_abs / den_abs;
         // Обчислюємо залишок (новий чисельник дробової частини)
         int remainder_num = num_abs % den_abs;
 
         // Якщо дріб від'ємний, додаємо знак мінус на початок рядка
         if (is_negative) {
             ss << "-";
         }
 
         // Якщо є ціла частина (не нуль)
         if (whole_part != 0) {
             ss << whole_part; // Додаємо цілу частину до рядка
             // Якщо є і ціла, і дробова частина, додаємо між ними пробіл
             if (remainder_num != 0) {
                 ss << " ";
             }
         }
 
         // Якщо є дробова частина (залишок від ділення не нуль)
         if (remainder_num != 0) {
             // Додаємо дробову частину у форматі "чисельник/знаменник"
             ss << remainder_num << "/" << den_abs;
         }
         // Випадок, коли є тільки ціла частина (remainder_num == 0), вже оброблений
         // Випадок, коли дріб нуль (whole_part == 0 && remainder_num == 0), оброблений на початку
 
         // Повертаємо сформований рядок з рядкового потоку
         return ss.str();
     }
 
     // Метод для отримання десяткового представлення дробу (тип double)
     double toDouble() {
         // Виконуємо ділення, перетворивши чисельник на double, щоб отримати дійсний результат
         return static_cast<double>(numerator) / denominator;
     }
 }; // Кінець оголошення класу Fraction
 
 // Головна функція програми
 int main() {
     int num, den;             // Цілочисельні змінні для чисельника та знаменника
     string input_line;        // Рядок для зберігання введених користувачем даних (напр., "3/4")
     string num_str, den_str;  // Рядки для зберігання виділених чисельника та знаменника
     size_t slash_pos;         // Змінна для зберігання позиції символу '/'
 
     // Просимо користувача ввести дріб і читаємо весь рядок
     // cout << "Введіть дріб у форматі чисельник/знаменник (наприклад, 3/4 або -7/2): "; // Можна додати підказку
     if (!getline(cin, input_line)) { // Читаємо рядок з консолі (cin) у змінну input_line
          // Якщо сталася помилка читання
          cerr << "Помилка читання вхідних даних." << endl;
          return 1; // Завершуємо програму з кодом помилки
     }
 
     // Шукаємо позицію роздільника '/' у введеному рядку
     slash_pos = input_line.find('/');
 
     // Перевіряємо, чи знайдено роздільник
     if (slash_pos == string::npos) { // string::npos - спеціальне значення, що означає "не знайдено"
         // Якщо '/' не знайдено, повідомляємо про невірний формат
         cerr << "Невірний формат введення. Очікується '[чисельник]/[знаменник]'." << endl;
         return 1; // Завершуємо програму з кодом помилки
     }
 
     // Виділяємо підрядок для чисельника (від початку до символу '/')
     num_str = input_line.substr(0, slash_pos);
     // Виділяємо підрядок для знаменника (від символу після '/' до кінця рядка)
     den_str = input_line.substr(slash_pos + 1);
 
     // Блок try-catch для безпечної конвертації рядків у числа
     try {
         // Конвертуємо рядок чисельника в ціле число
         num = stoi(num_str);
         // Конвертуємо рядок знаменника в ціле число
         den = stoi(den_str);
     } catch (const std::invalid_argument& ia) { // Перехоплюємо помилку невірного формату числа
          cerr << "Помилка конвертації: невірний формат числа у вхідних даних (" << ia.what() << ")" << endl;
         return 1; // Завершуємо програму з кодом помилки
     } catch (const std::out_of_range& oor) { // Перехоплюємо помилку виходу за межі діапазону int
          cerr << "Помилка конвертації: число виходить за межі допустимого діапазону (" << oor.what() << ")" << endl;
         return 1; // Завершуємо програму з кодом помилки
     }
 
      // Додаткова перевірка на нульовий знаменник після успішної конвертації
     if (den == 0) {
          cerr << "Помилка: Знаменник у введених даних не може бути нулем." << endl;
         return 1; // Завершуємо програму з кодом помилки
     }
 
     // Створюємо об'єкт класу Fraction, передаючи конструктору отримані чисельник і знаменник
     Fraction fraction(num, den);
 
     // Налаштування виводу для десяткових чисел
     cout << fixed;       // Використовувати формат з фіксованою комою (не експоненційний)
     cout.precision(2); // Встановити 2 знаки після коми для double
 
     // Виводимо результат у потрібному форматі
     // Викликаємо методи toString() і toDouble() створеного об'єкта fraction
     cout << fraction.toString() << " is " << fraction.toDouble() << " in decimal" << endl;
 
     // Повертаємо 0 з main, що сигналізує про успішне завершення програми
     return 0;
 } // Кінець функції main
